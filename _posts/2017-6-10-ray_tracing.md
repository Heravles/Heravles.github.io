#  Ray_tracing 光线追踪

### 实验目的
1.	加深对ray_tracing的理解与掌握。
2.	加强自己对图形学的理解
3.	加强自己对opengl的编程能力

### 硬件环境
I5+GTX960+8G mem


### 软件环境

Win10+vs2017

### 实验内容与步骤

#### 实验要求

1. 自行设计一个场景，在此场景下，利用Ray_tracing对该场景进行渲染，达到一个非常真实的效果
2. 高阶要求：实验中要求自我实现的，跟OPengl实现的对比，观察自己实现的效果图
#### 实验内容
1. ray_tracing 简介

光线跟踪是一种真实地显示物体的方法，该方法由 Appel在 1968年提出为了生成在三维计算机图形环境中的可见图像，光线跟踪是一个比光线投射或者扫描线渲染更加逼真的实现方法。这种方法通过逆向跟踪与假象的照相机镜头相交的光路进行工作，由于大量的类似光线横穿场景，所以从照相机角度看到的场景可见信息以及软件特定的光照条件，就可以构建起来。当光线与场景中的物体或者媒介相交的时候计算光线的反射、折射以及吸收。由于一个光源发射出的光线的绝大部分不会在观察者看到的光线中占很大比例，这些光线大部分经过多次反射逐渐消失或者至无限小，所以对于构建可见信息来说，逆向跟踪光线要比真实地模拟光线相互作用的效率要高很多倍。计算机模拟程序从光源发出的光线开始查询与观察点相交的光线从执行与获得正确的图像来说是不现实的。

2. 经典光线跟踪算法

![image](/images/tupian1.jpg)

 对图像中的每一个像素 {  
 
 创建从视点通过该像素的光线   初始化 最近T 为 无限大，最近物体 为 空值 
 
对场景中的每一个物体 {      
如果光线与物体相交 {  

如果交点处的 t 比 最近T 小 {    

  设置 最近T 为焦点的 t 值 
           设置 最近物体 为该物体 
           
        } 
        
     } 
     
  } 
 
  如果 最近物体 为 空值{ 
  
     用背景色填充该像素 
  } 否则 {
  
     对每个光源射出一条光线来检测是否处在阴影中
     如果表面是反射面，生成反射光；递归 
     如果表面透明，生成折射光；递归 
     使用 最近物体 和 最近T 来计算着色函数
     以着色函数的结果填充该像素 
  } 
}
 
Ray_casting使用的是物体搜索的办法：对每个物体进行搜索，因为场景中物体比较少，所以，对于每一个像素点，对每个物体进行搜索，所花时间比较少，当场景中物体比较多的时候，我们需要优化ray_casting算法

![image](/images/tupian2.png)

上图中，我们可以看到，我们对所有的x，y进行一个初始化的去全局遍历，这样就可以确定屏幕上每一个像素点的颜色值。然后对每一个点进行ray_tracing递归操作。


### ray_tracing具体部分

1.	计算观察光线的深度
首先我们初始化观察光线的深度为无穷大，然后计算与光线相交的物体，确定光线的相交深度，记录，然后确定好相交点最近的光线，改点为颜色点.

![image](/images/tupian3.png)

2.	对该交点进行初始化操作，初始化法向量，计算局部光照后，然后对改点反射光线进行递归调用的ray_tracing.

![image](/images/tupian4.png)

3.	局部光照的实现
局部光照的实现，主要是使用了Phong模型，利用的局部镜面反射以及局部漫反射的共同光线。

![image](images/tupian6.png)

### 实验中注意的要点：

1.	就是光线的递归终止条件：因为我这个场景中物体比较少，所以我规定的终止条件并不是光线强弱的判断，而是是不是光线反射到背景上，因为为题少，所以，光线反射到物体上以后，顶多两次递归，就会反射到背景上，这样就不会造成无限次的递归。
2.	场景中物体的设定：这个我是在一个xml文件中提前将场景中的物体设定好，在主文件找那个直接读取该文件，解析其中的场景信息即可

![image](/images/tupian5.png)

3. 场景中各种物体得规定都是放在其他的头文件以及.cpp文件中。


### 结论分析与体会：
1.	通过本次实验，更加了解opengl编程，提高自己设计程序的能力
2.	了解了opengl 的本质原理，对ray_tracing有了彻底的了解，知道了有些模拟自然界的东西，不一定按照自然界的原有的顺序来，ray_tracing就是利用了光线的反向
3.	更加全面的认识了计算机图形学。






